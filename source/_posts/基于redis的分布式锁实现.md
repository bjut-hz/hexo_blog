---
title: 基于redis的分布式锁实现
date: 2018-04-10 19:32:45
categories: 
- 分布式
tags:
- 分布式锁
- redis
---

## redis模型

Redis是基于单进程单线程模型的，即对于客户端的所有读写等请求的处理，都由一个主线程串行地处理。因此，利用该串行的性质，可以实现分布式锁。

<!-- more -->

## 单节点

基于单个redis节点，利用redis的串行执行命令的性质，实现分布式锁。可以认为把redis作为一个数据中心来用，多个客户端共同访问。

### 实现锁的正确姿势

##### 获取

        SET resource_name my_random_value NX PX 30000

上面的命令如果执行成功，则客户端成功获取到了锁，接下来就可以访问共享资源了；而如果上面的命令执行失败，则说明获取锁失败。

注意，在上面的`SET`命令中：

- `my_random_value`是由客户端生成的一个随机字符串，它要保证在足够长的一段时间内在所有客户端的所有获取锁的请求中都是唯一的。

- `NX`表示只有当`resource_name`对应的`key`值不存在的时候才能`SET`成功。这保证了只有第一个请求的客户端才能获得锁，而其它客户端在锁被释放之前都无法获得锁。
- `PX 30000`表示这个锁有一个30秒的自动过期时间。当然，这里30秒只是一个例子，客户端可以选择合适的过期时间。

##### 释放

使用lua脚本来释放;

    if redis.call("get",KEYS[1]) == ARGV[1] then
        return redis.call("del",KEYS[1])
    else
        return 0
    end

这段Lua脚本在执行的时候要把前面的`my_random_value`作为`ARGV[1]`的值传进去，把`resource_name`作为`KEYS[1]`的值传进去。

#### 关键点分析

- 过期时间设置

获取锁必须设置过期时间。否则的话，当客户端获取锁成功后，但是客户端发生崩溃或者由于发生了网络分区，都会导致不能与redis通信，因此永远不会释放被锁住的资源。因此必须对锁设置过期时间，并且客户端必须在这个时间间隔内完成对共享资源的访问，否则就失去了锁的意义。

- 不能能使用`setnx`与`expire`两条指令来获取锁

有一种方案把获取锁的操作分成了两步：

    SETNX resource_name my_random_value
    EXPIRE resource_name 30

虽然这两条指令与前面描述的`SET`指令执行效果相同，但是由于执行的过程中不是原子的，可能发生客户端在`SETNX`执行成功后崩溃，那么`EXPIRE`没有机会执行，那么会导致一直持有该锁。

但是是否可以使用lua脚本来原子性的执行这两个操作呢？

- `my_random_value`设置

设置`my_random_value`保证了一个客户端在释放锁的时候释放的是自己持有的那个锁。假设获取锁的时候设置的是一个固定的值，可能会发生一下序列：

1. c1获取锁M成功
2. c1在获取锁期间执行的操作超时了(超时是指超过了锁过期时间，比如阻塞操作)
3. 锁自动释放
4. c2获取了同一个锁M
5. 在c2获取锁的期间，c1恢复操作，此时执行锁释放操作，那么如果设置的是固定值，那么c1会释放掉c2持有的锁。之后c2访问共享资源时，就没有锁提供保护。

- 使用lua脚本释放锁

在redis中执行lua脚本能保证操作的原子性。释放锁其实包含三步操作：`GET`、判断和`DEL`，用Lua脚本来实现能保证这三步的原子性。如果把这三个步骤放到客户端中分开执行的话，就可能发生与上面类似的执行序列：

1. c1获取锁M成功
2. c1访问共享资源，并释放锁
3. c1释放锁，首先执行`GET`操作，但是由于某些原因(网络延迟，客户端得到`GET`结果延迟)，导致c1在执行`DEL`操作前已经超时。
4. 过期时间到，锁自动释放。
5. c2获取同一个锁M
6. 在c2获取锁的期间，c1执行`DEL`操作，c1释放掉c2持有的锁。之后c2访问共享资源时，就没有锁提供保护。

### 问题

- 单点故障

前面的注意点保证了分布式锁的正确性，但是由于是基于单节点实现分布式锁，所以如果该节点出现了故障，那么就会整个服务不可用。

redis提供了主从备份的机制，但是使用该机制也不能解决单点分布式锁面临的单点故障问题。为了提高可用性，我们可以给这个Redis节点挂一个Slave，当Master节点不可用的时候，系统自动切到Slave上（failover）。但由于Redis的主从复制（replication）是异步的，这可能导致在failover过程中丧失锁的安全性。考虑下面的执行序列：

1. c1从Master获取了锁。
2. Master宕机了，存储锁的key还没有来得及同步到Slave上。
3. Slave升级为Master。
4. c2从新的Master获取到了对应同一个资源的锁。

于是，c1和c2同时持有了同一个资源的锁。锁的安全性被打破。

- 过期时间设置

这个分布式锁的算法，需要设置锁的有效时间，那么设置多少合适呢？如果设置太短的话，锁就有可能在客户端完成对于共享资源的访问之前过期，从而失去保护；如果设置太长的话，一旦某个持有锁的客户端释放锁失败，那么就会导致所有其它客户端都无法获取锁，从而长时间内无法正常工作。是个两难的问题。

## 多节点Redlock

为了解决基于单点redis实现分布式锁服务存在的单点故障问题，redis作者antirez设计了Redlock算法。这个算法基于多个redis节点。